# Assembly Line Balancing with Simulated Annealing

## Problem Description

The **Assembly Line Balancing Problem (ALBP)** is a classic Operations Research problem that consists of distributing a set of tasks among workstations on an assembly line, while satisfying:

- **Precedence constraints**: certain tasks can only be performed after others have been completed
- **Cycle time minimization**: reduce the maximum time across all workstations (the bottleneck of the line)

Formally, given a set of $n$ tasks with processing times $t_i$ and a precedence graph $G = (V, E)$, the objective is to find an assignment of tasks to $m$ workstations that minimizes:

$$C = \max_{k=1}^{m} \sum_{i \in S_k} t_i$$

where $S_k$ is the set of tasks assigned to workstation $k$.

---

## Metaheuristic: Simulated Annealing

The algorithm implemented is **Simulated Annealing (SA)**, a metaheuristic inspired by the physical annealing process in metallurgy. The core idea is to allow moves to worse solutions with a certain probability, preventing the algorithm from getting trapped in local optima.

---

## Project Structure

```
.
├── assembly_line_balance_algorithm.py  # Main execution script
├── assembly_line.py                    # Assembly line reading and modelling
├── simulated_annealing_for_alb.py      # Simulated Annealing implementation
├── workstation.py                      # Workstation modelling
├── parameters                          # Per-instance parameters
└── input/
    ├── TONGE70.IN2                     # 70 tasks
    ├── WEE-MAG.IN2                     # 75 tasks
    ├── ARC83.IN2                       # 83 tasks
    └── SCHOLL.IN2                      # 297 tasks
```

---

## Module Descriptions

### `assembly_line.py` — Assembly Line Modelling

The `AssemblyLine` class is responsible for:

- Reading the input file in **IN2** format
- Storing the execution times of each task
- Building the complete **dependency graph** (direct and indirect) via recursive search

The dependency graph maps each task to the set of **all** tasks that must precede it, not just the direct relations from the input file.

### `workstation.py` — Workstation

The `WorkStation` class represents a workstation on the assembly line. Main responsibilities:

- Maintaining the list of assigned tasks
- Computing the **cycle time** of the workstation (sum of task times)
- Using the `has_changed` flag to avoid unnecessary recomputations (lazy evaluation)
- Supporting deep copy for neighbor solution generation

### `simulated_annealing_for_alb.py` — Optimization Algorithm

The core of the project. The `SimulatedAnnealingForALB` class implements:

#### Initial Solution Construction

Tasks are sorted in ascending order by number of dependencies (tasks with fewer prerequisites first) and distributed evenly across workstations.

#### Perturbation Operations (Neighborhood)

At each iteration, a neighbor solution is randomly generated by one of three operations:

| Action | Description |
|--------|-------------|
| `action = 0` | Swaps a task between two workstations |
| `action = 1` | Moves a task from workstation 2 to workstation 1 |
| `action = 2` | Moves a task from workstation 1 to workstation 2 |

#### Feasibility Validation

A solution is **infeasible** if there is a cycle in the dependencies between workstations. Infeasible solutions receive a penalty:

$$C_{penalty} = 100000$$

#### Algorithm Flow

```
1. Build initial solution
2. While T >= T_min:
   a. For each perturbation (up to max_disturbances):
      - Generate neighbor solution
      - Compute ΔE
      - If ΔE <= 0: accept (update optimum if improved)
      - If ΔE > 0: accept with probability e^(-ΔE/T)
      - If improvement found: break inner loop
   b. T = α * T
3. Return best solution found
```

### `assembly_line_balance_algorithm.py` — Main Execution

Orchestrates the experiments:

- For each instance and each workstation count configuration
- Runs **10 repetitions** of SA (due to its stochastic nature)
- Records the **best solution** found and its **execution time**
- Prints results in CSV format

---

## Benchmark Instances

| File | Tasks | Workstation Configurations | Cooling Rate |
|------|-------|---------------------------|--------------|
| `TONGE70.IN2` | 70 | 3, 4, 5, 6, 7, 8, 9, 10, 20 | 0.90 |
| `WEE-MAG.IN2` | 75 | 3, 4, 5, 6, 7, 12, 13, 14, 17 | 0.85 |
| `ARC83.IN2` | 83 | 6 | 0.85 |
| `SCHOLL.IN2` | 297 | 25, 35 | 0.85 |

---

## Input File Format (IN2)

```
n                   # number of tasks
t_1                 # task 1 time
t_2                 # task 2 time
...
t_n                 # task n time
i,j                 # precedence relation: task i precedes task j
...
-1,-1               # end marker (optional)
```

---

## How to Run

> Requirements: **Python 3.x** — no external dependencies.

```sh
python assembly_line_balance_algorithm.py
```

### Output

Results are printed in CSV format:

```
dataset,workstations,solution,execution_time
TONGE70.IN2,3,1245,3.72
TONGE70.IN2,4,987,2.10
...
```

| Field | Description |
|-------|-------------|
| `dataset` | Benchmark instance file name |
| `workstations` | Number of workstations used |
| `solution` | Best cycle time found |
| `execution_time` | Time to find the best solution (seconds) |

---

## Algorithm Parameters

| Parameter | Value | Description |
|-----------|-------|-------------|
| `initial_temperature` | Cycle time of the initial solution | Starting temperature |
| `cooling_rate` | 0.85 – 0.90 | Temperature decay rate |
| `max_disturbances` | $m \times n$ | Perturbations per temperature level |
| `MIN_TEMPERATURE` | 0.001 | Stopping criterion |
| `INFINITE_CYCLE_TIME` | 100000 | Infeasibility penalty |

---

## References

- Scholl, A. (1999). *Balancing and Sequencing of Assembly Lines*. Physica-Verlag.
- Kirkpatrick, S., Gelatt, C. D., & Vecchi, M. P. (1983). *Optimization by Simulated Annealing*. Science, 220(4598), 671–680.
- Tonge, F. M. (1961). *A Heuristic Program for Assembly Line Balancing*. Prentice-Hall.